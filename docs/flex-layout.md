
# Компоновка пользовательского интерфейса

## Yoga layout
Для компоновки пользовательского интерфейса применяется библиотека [Yoga layout](https://yogalayout.com/), разработанная в FaceBook для React Native. На карандаше была так же альтернатива, выраженная [grid](https://docs.microsoft.com/en-us/uwp/api/windows.ui.xaml.controls.grid) компоновкой как у WPF. Решающим критерием выбора стал факт того, что последняя плодит объекты при центровке.

WPF-like XAML
```
// __________________________________________________
// |              |                 |               |
// |   width: *   |     width: *    |   width: *    |
// |   height: *  |     height: *   |   height: *   |
// |______________|_________________|_______________|
// |              |                 |               |
// |   width: *   |   width: auto   |   width: *    |
// |   height: *  |   height: auto  |   height: *   |
// |______________|_________________|_______________|
// |              |                 |               |
// |   width: *   |     width: *    |   width: *    |
// |   height: *  |     height: *   |   height: *   |
// |______________|_________________|_______________|
//

<Grid x:Name="FormLayoutGrid" Grid.Row="1" Grid.Column="0">
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*" />
        <ColumnDefinition Width="Auto" />
        <ColumnDefinition Width="*" />
    </Grid.ColumnDefinitions>
    <Grid.RowDefinitions>
        <RowDefinition Height="*" />
        <RowDefinition Height="Auto" />
        <RowDefinition Height="*" />
    </Grid.RowDefinitions>
    <TextBlock Grid.Row="0" Grid.Column="0" />
<Grid/>
```

#### С Grid компоновкой приятнее работать, но:

 - Нет реализации с поддержкой от транснациональной корпорации 

    Только любительский код, не порядок

 - Ячейки 1,2,3,4,6,7,8,9 нужно чем-то заполнить

    Просто так поставить 8 пустых прозрачных прямоугольников


ReactNative-like JSX flexbox
```
// __________________________________________________
// |              |                 |               |
// |              |                 |               |
// |              |                 |               |
// |______________|_________________|_______________|
// |              |                 |               |
// |              |   width: 100    |               |
// |              |   height: 100   |               |
// |______________|_________________|_______________|
// |              |                 |               |
// |              |                 |               |
// |              |                 |               |
// |______________|_________________|_______________|

<Border alignItems={"center"} justifyContent={"center"}>
    <Rectangle height={100} width={100}>
</Border>

```

#### С Yoga Flex менее приятнее работать, так как:

 - Ведет себя она отлично от flex компоновки webkit

    Благо, в интернете есть [конструктор](https://yogalayout.com/playground) компоновки

 - Баги

    Можно нарваться на фантомные баги на разных компиляторах (следствие побайтовой оптимизаци). Благо, FaceBook активно исправляют ~~и создают новые~~.

#### Но:

 - Значительно быстрее в списках

    Меньше объектов на порядки. Выбрав Grid компоновку мы бы получили как в [Xamarin.Forms](https://github.com/xamarin/Xamarin.Forms) (Xamarin создали макрокомпонент для списков, чтобы не рендерить через абстракцию поэлементно. Понятно, из-за чего)

 - Поддержка FaceBook

    Без комментариев, всё выше.

## Когда фреймворк перерисовывает элементы:
При вызове методов **appendChild**, **insertAfterChild**, **delete** выбрасывается сигнал void Element::update(). Последний ловит родитель элемента и, когда счетчик применения изменений показывает 0 (DiffCounter::changesResolved()), запускает перерисовку позиций элементов применненного дочернего древа. 

Перерисовка дочернего древа бывает следующая:

 - У элемента вида "Window"

    Window это корневой элемент, у него нет родителя. Перерисовка его поддрева вызывается либо при окончании первичного рендеринга (топорного) или при изменении размера окна. Меняет позицию абсолютно всех дочерних элементов, что логично.

 - У элемента вида "Component"

    Компонент, тот самый, что с this.setState() и *.prototype.render(). Первый и единственный потомок получает 100% по ширине и 100% по высоте.

 - У элемента, исключая "Window" и "Component".

    При следующем рендеринге элемент генерирует новую компоновку с поправкой на существующий базис (отступ сверху и слева, ширина и высота).

Таким образом, каждый раз мы пересчитываем позиции минимального колличества элементов. Три пункта свехру реализуются переопределением рекурсивного метода `virtual FlexNode* buildFlexTree(bool fill=false);` у наследников элемента. При переборе потомков элемента он вызывает метод Element::startLayoutUpdate(). который, если элемент рендерится в первый раз, меняет его статус на "видимо". По умолчанию элемент скрыт - это сделано, чтобы не показывать начальную позицию и начать двигать его уже с заданной flex компоновкой.

Так же Element::startLayoutUpdate() предотвращает просчет компоновки у наследников окна, пока последнее не соизволит просчетать инициирующую позицию.

## Как фреймворк обновляет позицию элементов:

В результате работы рекурсивной функции FlexNode* Element::buildFlexTree(bool fill=false) или её перегрузки окна/компонента мы получаем флекс-ноду, соответствующую текущему элементу. Ей передается позиция предидущей копии флекс-ноды (см Element::updateLayoutNow()), затем она осуществляет пересчет позиции исходя из props элемента. Именно флекс-нода осуществляет парсинг строкового представления описания flex компоновки, а так же отладочный вывод с уклоном на вложенность элементов. 
